# 1. 脚本开头
## 1.1  shebang解释器

```
#!/bin/bash      #Bash
#!/bin/sh        #BourneShell
#!/usr/bin/pwsh  #PowerShell
#!/usr/bin/perl  #Per
#!/usr/bin/tcl   #TCL
#!/usr/bin/sed -f
#!/usr/bin/awk -f
#!/usr/bin/python3
#!/usr/bin/env python3
```
## 1.2 解释器选项

-  -e 当脚本发生第一个错误时, 就退出脚本, 换种说法就是, 当一个命令返回
非零值时, 就退出脚本;
-  -x 与-v选项类似, 但是会打印完整命令
-  -f  禁用Bash扩展
# 2. 注释
## 2.1 单行注释

```
#注释1
#注释2
```
## 2.2 多行注释

```
:<<EOF
注释1
注释2
EOF
```
# 3. 命令格式及操作符

## 3.1 基础格式

```
command [arg1 ... [argN]]
```

`command`是具体的命令或者一个可执行文件，`arg1 ... argN`是传递给命令的参数，它们是可选的。

```
ls -l
```

`ls`是命令,`-l`是参数
## 3.2 空格和TAB

Bash 使用空格（或 Tab 键）分割命令和参数。
如果参数之间有多个空格，Bash 会自动忽略多余的空格。
## 3.3 反斜杠（`\`）

Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。

```
./config --prefix=/usr/local/openssl \
--with-zlib-lib=/usr/local/zlib/lib \
--with-zlib-include=/usr/local/zlib/include \
enable-md2 \
shared
```

## 3.4 分号 `;`

分号（`;`）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。

```
clear ; ls -l
```

>[!IMPORTANT]
>使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败

## 3.5 命令组合符号 `&&`和`||`

除了分号，Bash 还提供两个命令组合符`&&`和`||`，允许更好地控制多个命令之间的继发关系。

```
Command1 && Command2
```

上面命令的意思是，如果`Command1`命令运行成功，则继续运行`Command2`命令。

```
Command1 || Command2
```

上面命令的意思是，如果`Command1`命令运行失败，则继续运行`Command2`命令。

## 3.6 `type`

`type`命令用来判断命令的来源。
如果要查看一个命令的所有定义，可以使用`type`命令的`-a`参数。
`type`命令的`-t`参数，可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）
# 4. 模式扩展
## 4.1 简介

Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。

这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。

-  波浪线（`~` ）
-  问号（`?`）
-  星号（`*`）
-  方括号（`[]`）
-  大括号（`{}`）
-  变量（`$`）
-  子命令 （\`Command\`或`$(Command)`）
-  算术（`$((...))`）
## 4.2 开启和关闭

关闭Bash扩展

```
$ set -o noglob
# 或者
$ set -f
```

重新打开Bash扩展

```
$ set +o noglob
# 或者
$ set +f
```

>[!IMPORTANT]
>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。

## 4.3 波浪线（`~` ）

波浪线`~`会自动扩展成当前用户的主目录。
`~user`表示扩展成用户`user`的主目录。

>[!NOTE]
>如果`~user`的`user`是不存在的用户名，则波浪号扩展不起作用。
>`~+`会扩展成当前所在的目录

## 4.4 问号（`?`）

`?`字符代表文件路径里面的任意单个字符，不包括空字符。

## 4.5 星号（`*`）

`*`字符代表文件路径里面的任意数量的任意字符，包括零个字符。

## 4.6  方括号（`[]`）

 ### 4.6.1 `[...]` `[^...]` `[!...]`
 
 `[aeiou]`可以匹配五个元音字母中的任意一个。
 
`[^abc]`或`[!abc]`表示匹配除了`a`、`b`、`c`以外的字符。

>[!NOTE]
>1.`[`字符，可以放在方括号内，比如`[[aeiou]`
>2.`-`字符，只能放在方括号内部的开头或结尾，比如`[-aeiou]`或`[aeiou-]`

 ### 4.6.2 `[start-end]` `[!start-end]`
 
 方括号扩展有一个简写形式`[start-end]`，表示匹配一个连续的范围。比如，`[a-c]`等同于`[abc]`，`[0-9]`匹配`[0123456789]`;
 否定形式`[!start-end]`，表示匹配不属于这个范围的字符。比如，`[!a-zA-Z]`表示匹配非英文字母的字符。

- `[a-z]`：所有小写字母。
- `[a-zA-Z]`：所有小写字母与大写字母。
- `[a-zA-Z0-9]`：所有小写字母、大写字母与数字。
- `[abc]*`：所有以`a`、`b`、`c`字符之一开头的文件名。
- `program.[co]`：文件`program.c`与文件`program.o`。
- `BACKUP.[0-9][0-9][0-9]`：所有以`BACKUP.`开头，后面是三个数字的文件名。

## 4.7 大括号（`{}`）

### 4.7.1 `{...}`

大括号扩展`{...}`表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，`{1,2,3}`扩展成`1 2 3`

```
#在opt目录下创建3个文件夹
mkdir -p /opt/{1,2,3}
```

>[!NOTE]
>大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。
>大括号内部的逗号前后可以没有值，表示空值。
>大括号可以嵌套。
>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。

### 4.7.2 {start..end}  `{start..end..step}`

大括号扩展有一个简写形式`{start..end}`，表示扩展成一个连续序列。比如，`{a..z}`可以扩展成26个小写英文字母。这种简写形式支持逆序。比如，`{z..a}`可以扩展成26个小写英文字母。

```
echo {{a..z},{z..a}}
echo {001..100}
echo {001..100..2}
echo {a..c}{1..10..2}
echo {a..c}{2..10..2}
```

## 4.8 变量（`$`）

Bash 将美元符号`$`开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。

```
echo $SHELL
```

变量名除了放在美元符号后面，也可以放在`${}`里面。

```
echo ${SHELL}
```

`${!string*}`或`${!string@}`返回所有匹配给定字符串`string`的变量名。

```
echo ${!S*}
```

上面例子中，`${!S*}`扩展成所有以`S`开头的变量名。

## 4.9  子命令 （\`Command\`或`$(Command)`）

`$(...)`可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。
还有另一种较老的语法，子命令放在\`\`反引号之中，也可以扩展成命令的运行结果。
`$(...)`可以嵌套，比如 `echo $(ls -l $(pwd))`。

```
echo `date`
echo $(date)
echo $(ls -l $(pwd))
```

## 4.10 算术（`$((...))`）

`$((...))`可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。

```
echo $((2 + 2))
```

# 5.  特殊字符

## 5.1  反斜杠`\`

1. 需要进行转义的特殊字符
	-  `$`
	-  `&`
	-  `*`
	-  `\`
	-  `` ` ``

1. 不可打印的字符
	- `\a`：响铃
	- `\b`：退格
	- `\n`：换行
	- `\r`：回车
	- `\t`：制表符


## 5.2 单引号 `'`

单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（`*`）、美元符号（`$`）、反斜杠（`\`）等。

单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。

>[!IMPORTANT]
>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（`$`），然后再对里层的单引号转义。
>例如
>`echo $'it\'s'`
>更合理的做法`echo "it's"`


## 5.3 双引号`"`

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。

- 美元符号（`$`）
- 反引号（`` ` ``）
- 反斜杠（`\`）

## 5.4 Here文档

Here 文档（here document）是一种输入多行字符串的方法，格式如下。

```
<< token
text
token
```

>[!NOTE]
>它的格式分成开始标记（`<< token`）和结束标记（`token`）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。

Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。

```
$ foo='hello world'
$ cat << _example_
$foo
"$foo"
'$foo'
_example_

hello world
"hello world"
'hello world'
```

如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。

```
$ foo='hello world'
$ cat << '_example_'
$foo
"$foo"
'$foo'
_example_

$foo
"$foo"
'$foo'
```

上面例子中，Here 文档的开始标记（`_example_`）放在单引号之中，导致变量替换失效了。

Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了`echo`命令。

```
$ command << token
  string
token

# 等同于

$ echo string | command
```

上面代码中，Here 文档相当于`echo`命令的重定向。

Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（`<<<`）表示。它的作用是将字符串通过标准输入，传递给命令。

```
<<< string
```

有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如`cat`命令只接受标准输入传入的字符串。

```
$ cat <<< 'hi there'
# 等同于
$ echo 'hi there' | cat
```

上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。

```
$ md5sum <<< 'ddd'
# 等同于
$ echo 'ddd' | md5sum
```

上面例子中，`md5sum`命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即`md5sum ddd`里面的`ddd`会被解释成文件名。这时就可以用 Here 字符串，将字符串传给`md5sum`命令。
# 6. 变量

## 6.1

Bash 变量分成环境变量和自定义变量两类。
### 6.1.1 环境变量

环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。

`env`命令或`printenv`命令，可以显示所有环境变量。

```
$ env
# 或者
$ printenv
```

下面是一些常见的环境变量。

- `BASHPID`：Bash 进程的进程 ID。
- `BASHOPTS`：当前 Shell 的参数，可以用`shopt`命令修改。
- `DISPLAY`：图形环境的显示器名字，通常是`:0`，表示 X Server 的第一个显示器。
- `EDITOR`：默认的文本编辑器。
- `HOME`：用户的主目录。
- `HOST`：当前主机的名称。
- `IFS`：词与词之间的分隔符，默认为空格。
- `LANG`：字符集以及语言编码，比如`zh_CN.UTF-8`。
- `PATH`：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。
- `PS1`：Shell 提示符。
- `PS2`： 输入多行命令时，次要的 Shell 提示符。
- `PWD`：当前工作目录。
- `RANDOM`：返回一个0到32767之间的随机数。
- `SHELL`：Shell 的名字。
- `SHELLOPTS`：启动当前 Shell 的`set`命令的参数。
- `TERM`：终端类型名，即终端仿真器所用的协议。
- `UID`：当前用户的 ID 编号。
- `USER`：当前用户的用户名。

很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。

>[!NOTE]
>Bash 变量名区分大小写，`HOME`和`home`是两个不同的变量。

查看单个环境变量的值，可以使用`printenv`命令或`echo`命令。

```
$ printenv PATH
# 或者
$ echo $PATH
```

>[!NOTE]
>`printenv`命令后面的变量名，不用加前缀`$`。

### 6.1.2 自定义变量

自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。

`set`命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

```
$ set
```

## 6.2 创建变量

用户创建变量的时候，变量名必须遵守下面的规则。

- 字母、数字和下划线字符组成。
- 第一个字符必须是一个字母或一个下划线，不能是数字。
- 不允许出现空格和标点符号。

变量声明的语法如下。

```
variable=value
```

上面命令中，等号左边是变量名，右边是变量。

>[!NOTE]
>注意，等号两边不能有空格。

如果变量的值包含空格，则必须将值放在引号中。

```
myvar="hello world"
```

Bash 没有数据类型的概念，所有的变量值都是字符串。

下面是一些自定义变量的例子。

```
a=z                     # 变量 a 赋值为字符串 z
b="a string"            # 变量值包含空格，就必须放在引号里面
c="a string and $b"     # 变量值可以引用其他变量的值
d="\t\ta string\n"      # 变量值可以使用转义字符
e=$(ls -l foo.txt)      # 变量值可以是命令的执行结果
f=$((5 * 7))            # 变量值可以是数学运算的结果
```

变量可以重复赋值，后面的赋值会覆盖前面的赋值。

```
$ foo=1
$ foo=2
$ echo $foo
2
```

上面例子中，变量`foo`的第二次赋值会覆盖第一次赋值。

如果同一行定义多个变量，必须使用分号（`;`）分隔。

```
$ foo=1;bar=2
```

上面例子中，同一行定义了`foo`和`bar`两个变量。

## 6.3 读取变量

读取变量的时候，直接在变量名前加上`$`就可以了。

```
$ foo=bar
$ echo $foo
bar
```

每当 Shell 看到以`$`开头的单词时，就会尝试读取这个变量名对应的值。

如果变量不存在，Bash 不会报错，而会输出空字符。

由于`$`在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，

```
$ echo The total is $100.00
The total is 00.00
```

上面命令的原意是输入`$100`，但是 Bash 将`$1`解释成了变量，该变量为空，因此输入就变成了`00.00`。所以，如果要使用`$`的原义，需要在`$`前面放上反斜杠，进行转义。

```
$ echo The total is \$100.00
The total is $100.00
```

读取变量的时候，变量名也可以使用花括号`{}`包围，比如`$a`也可以写成`${a}`。这种写法可以用于变量名与其他字符连用的情况。

```
$ a=foo
$ echo $a_file

$ echo ${a}_file
foo_file
```

上面代码中，变量名`a_file`不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分`$a`，Bash 才能正确解读。

事实上，读取变量的语法`$foo`，可以看作是`${foo}`的简写形式。

如果变量的值本身也是变量，可以使用`${!varname}`的语法，读取最终的值。

```
$ myvar=USER
$ echo ${!myvar}
ruanyf
```

上面的例子中，变量`myvar`的值是`USER`，`${!myvar}`的写法将其展开成最终的值。

如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。

```
$ a="1 2  3"
$ echo $a
1 2 3
$ echo "$a"
1 2  3
```

上面示例中，变量`a`的值包含两个连续空格。如果直接读取，Shell 会将连续空格合并成一个。只有放在双引号里面读取，才能保持原来的格式。
